# Задание 1 Краевая задача
# y''+1,5y'-xy=0,5 основное уравнение
# 2y(0)-y'(0)=1   краевое условие для левой границы
# y(1)=3          краевое условие для правой границы
# ------------------------------------------------------------------

# Дальше приводем наше уравнение к новой системе уравнений
# { y'=z            =f
# { z'=0.5-1.5z+xy  =g

def f(x, y, z):
    return z
def g(x, y, z):
    return 0.5-1.5*z+x*y

# Начальные условие которые известны или которые мы задаём
n = 100  # Количество разбиений (сами выбираем)
eps = 1e-7  # точность вычисления
a = 0    # начало отрезка
b = 0.6  # конец отрезка
# Находим шаг сетки
h = (b - a) / n
xi = [h * i + a for i in range(n)]


                 # Метод Эйлера ( z(0) Мы будем предпологать это какое-то t которое мы задаём)
                                    # { y(x0)=y0
                                    # { z(x0)=z0

                                    # { y(x1)=y(x0)+h*f(x0,y0,z0)
                                    # { z(x1)=z(x0)+h*g(x0,y0,z0)
                                    # ...........................

                                    # { y(xi+1)=y(xi)+h*f(xi,yi,zi)
                                    # { z(xi+1)=z(xi)+h*g(xi,yi,zi)

def eylera(t):
    global y, z  # Пустые списки, где будут лежать все yi и zi, которые найдём по методу Эйлера
    # Зададим какие-то начальные условия
    # z(0)=t
    z = [t, ]
    # 2y(0)=t+1 => y(0)=(t+1)/2
    y = [(t+1) / 2, ]
    # Дальше в цикле добавляем остальные в конец списка
    for i in range(1, n):
        y.append(y[-1] + h * f(xi[i - 1], y[-1], z[-1]))
        z.append(z[-1] + h * g(xi[i - 1], y[-1], z[-1]))
    return y[-1] - 3  # -3 так как должно совпадать со вторым граничным условием

                                          # Метод Ньютона
                                              # t0=a
                                        # t1=t0-F(t0)/F'(t0)
                                        # t2=t1-F(t1)/F'(t1)
                                        # ..................
                                       # ti+1=ti-F(ti)/F'(ti)

def nyuton():
    d = 0.5  # погрешность
    t0 = -6  # Какое-то начальное условие, которое сами выбираем
    while eps < d:  # Заканчиваем как только |ti+1-ti|<eps
        f = eylera(t0)
        F = f * 1e-4 / (eylera(t0 + 1e-4) - f)  # по формуле вычисления производной F'(t)=(F(t+ep)-F(t))/eps
        t1 = t0 - F
        d = abs(t0 - t1)
        t0 = t1  # делаем t0 как t1 чтобы найти t2 и так далее

nyuton()
print("На левой границе", 2*y[0] - z[0])   # проверка краевых условий
print("На правой границе", y[-1])          # проверка краевых условий (ответ выходит с небольшой погрешностью)
print(y)                                   # массив yi